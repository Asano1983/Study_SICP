
書籍の要約ではなくて、自分が思ったことを記録する。

# 1 手続きによる抽象の構築

序文は難しい。
データとプロセスというものがあるらしい。
データはなんとなくわかるが、プロセスとはなんぞや。

プログラム言語で記述される何らかの「手続き」で、インタープリタで処理される前のものであるらしいが、
ちゃんと定義が書いているわけではない。

和田訳ではプロセスの手続きという用語ができたりして、何を言っているのかわからなかったので、原文を読んだところ

The most significant of these features is the fact that Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data.

と書いてあって、プロセスをLispで記述したものを「procedure」と呼び、procesureをLispのデータとして表現したり操作したりできるということらしい。

## 1.1 プログラムの要素

### 1.1.1 式

Schemeでは全て前置記法だよ。

メリット

- インタープリタの実装が容易（構文木そのまま）。
- 演算子の優先順位を決めてなくてよい。

デメリット

- カッコだらけになる。

うまくインデントすれば、可読性はそこまでひどいことにはならないようだ。

```Scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

このように被演算子が垂直に整列するように書く方法をpretty printという。

しかしホントに構文木そのままなのね。
人間よりインタープリタに優しい言語に見える。

### 1.1.2 名前と環境

特殊形式defineが登場。
defineすると名前とオブジェクトの対が「環境」に登録される。
名前とオブジェクトは対応しているだけで同じものではないことに注意。

### 1.1.3 組合せの評価

(演算子 被演算子 被演算子 被演算子)みたいな文字列を「組合せ」というらしい。
defineは特殊形式であって、演算子ではないので、
(define x 3)は組合せではない。

組合せの評価は、演算子を被演算子（引数）たちに作用させるというものである。
特殊形式はそういうものではない（上の例でいうとdefineがxや3に作用するわけではない）。

### 1.1.4 合成手続き

```Scheme
(define (square x) (* x x))
```

のようにユーザー定義された演算子を合成手続きという。
（一度定義してしまえば）合成手続きと組み込みの手続きを区別する意味はなさそうである。

Schemeは数と関数の名前空間が同じであるが（Lisp-1）、数と0引数関数は区別されているようである。

```
> (define a 2)
> a
2
> (define (f) 2)
> f
#<procedure:f>
```

### 1.1.5 手続き作用の置換えモデル

仮パラメータを値に置き換えていく手順のことを置換えモデルという。
人間が手続き作用を考えるときのモデルであって、インタープリタの実際の動きを説明するためのものではない
（インタープリタは文字列操作をするわけではない）。

演算子を先に展開してから、後で簡約する方法を正規順序の評価といい、
先に引数を評価してから作用させる方法を作用的順序の評価という。
Lispは作用的順序の評価を使っているが、遅延ストリームなどの理解においては正規順序の評価も重要であるらしい（3章や4章で扱う）。

正規順序の評価は最外最左簡約や名前呼びともいう。
この評価戦略は同じ引数を複数回評価してしまうという性能上の欠点がある。
実用的な言語で採用されることはないはずである。

Haskellの評価戦略は必要呼び（call by need）と言って、引数評価をメモ化して置き、同じ引数を複数回評価しないようになっている。
副作用がなければ、必要呼びによる計算結果は正規順序の評価の計算結果と一致するが、
副作用があればその限りではない（Haskellは副作用禁止なので大丈夫）。

### 1.1.6 条件式と述語

cond、if、and、or、notなどの紹介。
cond、if、and、orは短絡評価が必要なため特殊形式であるが、notは通常の演算子である。

#### 問題1.1

引き算や割り算も３つ以上の引数を取れるらしい。

```
> (- 9 1 2)
6
> (/ 36 2 3)
6
```

#### 問題1.5

```Scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

pは自分自身で再帰的に定義されていて、pを評価すると計算が停止しない（計算機科学でいう⊥）。
しかし、インタープリタが正規順序の評価に従うのであれば、

```Scheme
(test 0 (p))
```

は停止する（pを評価しないので）。
作用的順序の評価に従うのならば停止しない。
このため、このテストによって、インタープリタが正規順序であるか作用的順序であるかを判定することができる。

Haskell（GHCi）で試してみた。

```
Prelude> let p = p
Prelude> let test x y = if x == 0 then 0 else y
Prelude> test 0 p
0
```

ちゃんと停止する。

