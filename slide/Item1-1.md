
書籍の要約ではなくて、自分が思ったことを記録する。

# 1 手続きによる抽象の構築

序文は難しい。
データとプロセスというものがあるらしい。
データはなんとなくわかるが、プロセスとはなんぞや。

プログラム言語で記述される何らかの「手続き」で、インタープリタで処理される前のものであるらしいが、
ちゃんと定義が書いているわけではない。

和田訳ではプロセスの手続きという用語ができたりして、何を言っているのかわからなかったので、原文を読んだところ

The most significant of these features is the fact that Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data.

と書いてあって、プロセスをLispで記述したものを「procedure」と呼び、procesureをLispのデータとして表現したり操作したりできるということらしい。

## 1.1 プログラムの要素

### 1.1.1 式

Schemeでは全て前置記法だよ。

メリット

- インタープリタの実装が容易（構文木そのまま）。
- 演算子の優先順位を決めてなくてよい。

デメリット

- カッコだらけになる。

うまくインデントすれば、可読性はそこまでひどいことにはならないようだ。

```Scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

このように被演算子が垂直に整列するように書く方法をpretty printという。

しかしホントに構文木そのままなのね。
人間よりインタープリタに優しい言語に見える。

### 1.1.2 名前と環境

特殊形式defineが登場。
defineすると名前とオブジェクトの対が「環境」に登録される。
名前とオブジェクトは対応しているだけで同じものではないことに注意。

### 1.1.3 組合せの評価

(演算子 被演算子 被演算子 被演算子)みたいな文字列を「組合せ」というらしい。
defineは特殊形式であって、演算子ではないので、
(define x 3)は組合せではない。

組合せの評価は、演算子を被演算子（引数）たちに作用させるというものである。
特殊形式はそういうものではない（上の例でいうとdefineがxや3に作用するわけではない）。

### 1.1.4 合成手続き

```Scheme
(define (square x) (* x x))
```

のようにユーザー定義された演算子を合成手続きという。
（一度定義してしまえば）合成手続きと組み込みの手続きを区別する意味はなさそうである。

Schemeは数と関数の名前空間が同じであるが（Lisp-1）、数と0引数関数は区別されているようである。

```
> (define a 2)
> a
2
> (define (f) 2)
> f
#<procedure:f>
```

### 1.1.5 手続き作用の置換えモデル

仮パラメータを値に置き換えていく手順のことを置換えモデルという。
人間が手続き作用を考えるときのモデルであって、インタープリタの実際の動きを説明するためのものではない
（インタープリタは文字列操作をするわけではない）。

演算子を先に展開してから、後で簡約する方法を正規順序の評価といい、
先に引数を評価してから作用させる方法を作用的順序の評価という。
Lispは作用的順序の評価を使っているが、遅延ストリームなどの理解においては正規順序の評価も重要であるらしい（3章や4章で扱う）。

正規順序の評価は最外最左簡約や名前呼びともいう。
この評価戦略は同じ引数を複数回評価してしまうという性能上の欠点がある。
実用的な言語で採用されることはないはずである。

Haskellの評価戦略は必要呼び（call by need）と言って、引数評価をメモ化して置き、同じ引数を複数回評価しないようになっている。
副作用がなければ、必要呼びによる計算結果は正規順序の評価の計算結果と一致するが、
副作用があればその限りではない（Haskellは副作用禁止なので大丈夫）。

### 1.1.6 条件式と述語

cond、if、and、or、notなどの紹介。
cond、if、and、orは短絡評価が必要なため特殊形式であるが、notは通常の演算子である。

#### 問題1.1

引き算や割り算も３つ以上の引数を取れるらしい。

```
> (- 9 1 2)
6
> (/ 36 2 3)
6
```

#### 問題1.5

```Scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

pは自分自身で再帰的に定義されていて、pを評価すると計算が停止しない（計算機科学でいう⊥）。
しかし、インタープリタが正規順序の評価に従うのであれば、

```Scheme
(test 0 (p))
```

は停止する（pを評価しないので）。
作用的順序の評価に従うのならば停止しない。
このため、このテストによって、インタープリタが正規順序であるか作用的順序であるかを判定することができる。

Haskell（GHCi）で試してみた。

```
Prelude> let p = p
Prelude> let test x y = if x == 0 then 0 else y
Prelude> test 0 p
0
```

ちゃんと停止する。

### 1.1.7 Newton法による平方根

再帰を使ってNewton法を実装する話。
本文には「ループ構文がなくても書けるからすごい！」って書いてあるが、再帰はループより強力なので当たり前な気がする。

```Scheme
(define (square x) (* x x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (my-sqrt x)
  (sqrt-iter 1.0 x))
```

ここでは実装用関数（sqrt-iterなど）も公開されてしまっているが、次の1.1.8で実装用関数を隠蔽する。

#### 問題1.6

ifはなぜ特殊形式なのかという話。
Schemeは正格評価（値呼び）なので、通常の関数として定義してしまうと、
常にthen節とelse節の両方を評価してしまう。
例えば、上のsqrt-iterのifが通常の関数ならば、計算が止まらなくなってしまう。

#### 問題1.7

上のgood-enough?はxが小さい数の時には困るが、非常に大きな数であっても困る。

```
> (my-sqrt 1e-10)
0.03125000106562499
```

小さいときは誤差の評価自体が不適切である。

```
> (my-sqrt 1e100)
```

非常に大きいときは、丸め誤差のため計算が止まらなくなってしまう。

### 1.1.8 ブラックボックス抽象としての手続き

自由変数と束縛変数の話がちょろっと書いてある。
束縛変数（ローカル変数）の名前をリネームしても意味は変わらない。
変数が束縛されている範囲をスコープという、など。
α変換の厳密な定義について書いてあるわけではない。

```Scheme
(define (square x) (* x x))

(define (average x y)
  (/ (+ x y) 2))

(define (my-sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))
  (sqrt-iter 1.0 x))
```

呼び出し側に見せる必要がない関数はブロック構造を使って隠蔽しよう。

レキシカル・スコーピングという用語は出てくるが、ダイナミック・スコーピングの話は無し。
ダイナミック・スコーピングは忘れよう（今となってはEmacs Lispぐらいなものだろう）。
ラムダ計算は自然にレキシカル・スコーピングである。

余談：
C++のような言語でもラムダ式を外側の変数に代入するとスコープが複雑になる。

```C++
#include <functional>

int main()
{
    std::function<int(int)> func;
    
    {
        int a = 3;
        func = [a](int x){return a * x;};
    }
    
    return func(5);
}
```

これはちゃんと15を戻してくれるが（funcが持つaはコピーで作られるので）

```
#include <functional>

int main()
{
    std::function<int(int)> func;
    
    {
        int a = 3;
        func = [&a](int x){return a * x;};
    }
    
    return func(5);
}
```

これはfuncが持つ参照がdangleになってしまうので未定義動作。

Schemeの場合

```Scheme
(define (func x) 0)

(define (hoge)
  (define a 3)
  (set! func (lambda (x) (* a x)))
  (define a 5)
  0)
```

みたいなことをすると

```
> (hoge)
0
> (func 10)
50
```

となるので、多分参照が渡されているんだと思うが、dangleことはたぶんないんだと思う。きっと。
このaはfuncから見れば自由変数に見えるが、クライアントから見れば隠蔽されている。

